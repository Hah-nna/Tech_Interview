# JavaScript

## 23.11.25

- 변수(var, let, const)
- 호이스팅

---

- 태영

var, let, const 의 차이
var
var는 중복 선언이 가능하다. 그래서 기존에 선언한 변수를 잊고 값을 재 할당 하는 실수를 할수 있다.
var은 재할당이 가능하다.
var는 최상위에 끌어올려진 것 처럼 동작한다 (호이스팅)
var는 함수 스코프 안에서만 지역 변수 이고 이외의 곳에서는 전역 변수이다.
let
let은 중복 선언이 되지 않는다.
let은 재할당이 가능하다.
let은 호이스팅이 되지만 TDZ(Templar Dead Zone)때문에 참조에러가난다. - 선언 전에는 사용할수 없으며 코드를 예측가능하게하고 잠재적인버그를 줄일 수 있다.
let은 블록스코프 이며 블록스코프 이외에서는 전역 변수 이다.
const
const는 선언+초기화+할당 단계가 한번에 이루어진다.
const 는 재할당이 되지 않는다.
const도 호이스팅은 되지만 TDZ에 적용되어 선언전에는 접근 할수 없다.
const 는 블록 스코프이다.
호이스팅
호이스팅이란 변수 선언과 함수 선언을 코드의 맨 위로 끌어올려지는 현상을 말한다.
javascript엔진이 코드를 실행하기 전에 선언들을 메모리에 저장하는 방식 때문에 발생한다.
변수 생성과 초기화의 작업이 분리되어 진행 되기 때문에 발생된다.

변수의 호이스팅
var로 선언된 변수는 초기화 되지 않은 상태 Undefined로 호이스팅된다.
let,const 는 TDZ에 들어가 변수가 선언되기 전까지 접근 할수 없어 이기간동안 변수에 접근하려고 하면 참조에러가 난다

함수의 호이스팅
함수는 함수 선언식은 선언전에도 호출할수 있다. 함수선언이 스코프의 최상단으로 완전히 호이스팅되기 때문이다.
함수 표현식은 변수에 할당 하므로 변수 선언후 에 함수를 아직 할당 받지 못한상태로 호출 하여 error가 발생한다.

- 하나

# JavaScript

## Variables(var, let, const )

### var

- 중복선언 O , 재할당 O

```
var a = 1;
var a = 10
a = 2

console.log(a) // 2
```

- 전역 변수로 선언한 경우 window 객체의 속성이 됨

```
var a = 'hi';
console.log(window.a) // 'hi';
```

- 호이스팅될 때 초기화됨

```
console.log(x) // undefined
var x = 1
console.log(x) // 1

```

- 함수 스코프를 가짐
  (함수 내부에서 어디든 var로 선언한 변수에 접근할 수 있음)

```
function example() {
  if (true) {
    var a = 1;
  }

  for (var i = 0; i < 5; i++) {
    console.log(i, "i") // 0 1 2 3 4
  }

  console.log(a); // 1
  console.log(i); // 5
}

example();
```

### let

- 중복선언 X, 재할당 O

```
let b = 1
b = 2
console.log(b) // 2

-----------------------------
let p = 111
let p = 222 // error
```

- 선언문 이전 접근 불가(참조할 값이 없기 때문에 참조 에러 발생) -> 변수의 중복 선언을 막을 수 있음

```
console.log(x) // 참조 에러
let x = 1
```

- 블록 스코프를 가짐 (선언된 블록({}) 안에서만 접근이 가능함 )

```
function example() {
  if (true) {
    let a = 1;
  }

  for (let i = 0; i < 5; i++) {
    console.log(i, "i") // 0 1 2 3 4
  }

  console.log(a); // 참조 에러
  console.log(i); // 참조 에러
}

example();
```

### const

- 중복선언X, 재할당 X
- let과 마찬가지로 선언문 이전 접근 불가
- 객체가 할당되는 경우 객체 안의 값을 바꿀 수 있음(새로운 값을 재할당하는 것이 아니므로)
- 블록 스코프를 가짐 (선언된 블록({}) 안에서만 접근이 가능함 )

## Hoisting

`호이스팅`이란 간단하게 말하자면 선언부가 제일 최상단으로 끌어올려진 것 같은 현상을 말함

자바스크립트 엔진은 코드를 위에서 아래로 읽어나감. 그 과정에서 선언해둘 것이 있다면 먼저 선언해두는데, 선언하는 과정에서 실행한 실행 컨텍스트(아래 예시의 경우 전역 컨텍스트) 안에 새로운 식별자(아래 예시에서는 cat)를 environment record에 저장함. 아래 예시의 경우 cat은 var 키워드로 되어있기 때문에 초기화를 함

```
console.log(cat) // undefined

var cat = 'rey';

console.log(cat) // 'rey'
```

let이나 const로 선언한 경우 자바스크립트 엔진이 environment record에 저장을 하긴 하지만 값을 초기화하지 않음.
따라서 식별자 cat의 값을 참조할 수 없으므로 참조 에러가 발생함(자바스크립트 엔진이 cat의 값을 읽을 수 없기 때문)

즉, let이나 const로 선언했을 때 선언 이전에 식별자를 참조할 수 없는 구역인 TDZ(temporal Dead Zone)가 발생함

```
console.log(cat) // reference error

let cat = 'rey';

console.log(cat) // rey

```

---

## 정리

### 변수

`var`

- 중복선언 O , 재할당 O
- 전역 변수로 선언한 경우 window 객체의 속성이 됨
- 호이스팅될 때 초기화됨
- 함수 스코프를 가짐

`let`

- 중복선언 X, 재할당 O
- 선언문 이전 접근 불가(참조할 값이 없기 때문에 참조 에러 발생) -> 변수의 중복 선언을 막을 수 있음

`const`

- 중복선언X, 재할당 X
- let과 마찬가지로 선언문 이전 접근 불가
- 객체가 할당되는 경우 객체 안의 값을 바꿀 수 있음(새로운 값을 재할당하는 것이 아니므로)
- 블록 스코프를 가짐 (선언된 블록({}) 안에서만 접근이 가능함 )

### 호이스팅

1. 변수 호이스팅

- var 로 변수를 선언한 경우 <u>선언</u>과 <u>초기화</u>가 동시에 일어남
- let, const의 경우 초기화하지 않음 -> 따라서 값이 할당되기 전까지는 변수에 아무런 값이 담겨있지 않기 때문에 값을 읽을 수 없음 -> 선언 라인 이전에는 변수를 참조할 수 없음(TDZ 발생)

`선언`
메모리 공간을 확보하고 메모리 주소에 식별자와 연결

`초기화`
식별자에 암묵적으로 undefined 값 바인딩

2. 함수 호이스팅

- 함수 선언문의 경우 함수선언문 전체가 호이스팅됨
- 함수 표현식의 경우 선언부만 호이스팅됨
